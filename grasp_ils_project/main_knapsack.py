# -*- coding: utf-8 -*-
"""GRASP_ILS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qzXeoHT8919XUbN7YQ2yYGybW8mH_gIf
"""

#!/usr/bin/env python3
# Reactive GRASP + ILS approach to colve 0/1 Knapsack Problem

import sys, time, random

def read_input():
    data = sys.stdin.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, 0, []
    W = int(next(it))
    items = []
    for _ in range(n):
        d = int(next(it)); w = int(next(it))
        items.append({'d': d, 'w': w})
    return n, W, items

def greedy_pack(n, W, items, idx):
    used = [0]*n
    tw = td = 0
    for i in idx:
        wi = items[i]['w']
        if tw + wi <= W:
            used[i] = 1
            tw += wi
            td += items[i]['d']
    return used, tw, td

def grasp_construct(n, W, items, idx, alpha):
    used = [0]*n
    tw = td = 0
    remain = W
    while True:
        # find best ratio among feasible
        max_r = 0.0
        for i in idx:
            if not used[i] and items[i]['w'] <= remain:
                r = items[i]['d']/items[i]['w']
                if r > max_r:
                    max_r = r
        if max_r == 0.0:
            break
        threshold = alpha * max_r
        rcl = [i for i in idx
               if not used[i]
               and items[i]['w'] <= remain
               and items[i]['d']/items[i]['w'] >= threshold]
        if not rcl:
            break
        pick = random.choice(rcl)
        used[pick] = 1
        tw += items[pick]['w']
        td += items[pick]['d']
        remain = W - tw
    return used, tw, td

def local_search(used, items, W, idx, start_time, time_limit, max_no_improve, M):
    tw = sum(items[i]['w'] for i,u in enumerate(used) if u)
    td = sum(items[i]['d'] for i,u in enumerate(used) if u)
    no_improve = 0
    while no_improve < max_no_improve and (time.time() - start_time) < time_limit:
        sel   = [i for i,u in enumerate(used) if u]
        unsel = [i for i,u in enumerate(used) if not u]
        if not sel or not unsel:
            break
        # focus on M worst in-bag and M best out-of-bag
        sel.sort(key=lambda i: items[i]['d']/items[i]['w'])
        unsel.sort(key=lambda i: items[i]['d']/items[i]['w'], reverse=True)
        improved = False
        for i in sel[:M]:
            for j in unsel[:M]:
                new_w = tw - items[i]['w'] + items[j]['w']
                if new_w <= W:
                    new_d = td - items[i]['d'] + items[j]['d']
                    if new_d > td:
                        used[i], used[j] = 0, 1
                        tw, td = new_w, new_d
                        improved = True
                        break
            if improved:
                break
        if improved:
            no_improve = 0
        else:
            no_improve += 1
    return used, tw, td

def perturb(used, items, W, idx, drop_rate):
    used_idxs = [i for i,u in enumerate(used) if u]
    if not used_idxs:
        return used
    P = max(1, int(len(used_idxs) * drop_rate))
    to_drop = random.sample(used_idxs, P)
    for i in to_drop:
        used[i] = 0
    # refill greedily
    tw = sum(items[i]['w'] for i,u in enumerate(used) if u)
    for i in idx:
        if not used[i] and tw + items[i]['w'] <= W:
            used[i] = 1
            tw += items[i]['w']
    return used

def sample_adaptive(dist):
    total = sum(dist.values())
    r = random.random() * total
    cum = 0.0
    for x, w in dist.items():
        cum += w
        if r <= cum:
            return x
    return next(iter(dist))

def print_solution(used, td):
    """Prints total satisfaction and chosen items indices (0-based)."""
    chosen = [str(i) for i, u in enumerate(used) if u]
    print(td)
    if chosen:
        print("Chosen item indices:", " ".join(chosen))
    else:
        print("Chosen item indices:")

def main():
    n, W, items = read_input()
    if n == 0:
        print(0)
        print("Chosen item indices:")
        return

    # prepare
    idx = list(range(n))
    idx.sort(key=lambda i: items[i]['d']/items[i]['w'], reverse=True)
    best_single = max((it['d'] for it in items if it['w'] <= W), default=0)
    best_used = None

    # small instances: pure greedy + quick polish
    if n <= 1000:
        used, tw, td = greedy_pack(n, W, items, idx)
        start = time.time()
        used, tw, td = local_search(used, items, W, idx,
                                    start, 1.0, 200, 100)
        # Compare with best single-item solution
        if best_single > td:
            # If a single item is better, construct that solution
            used = [0]*n
            # pick the single item with value = best_single
            for i, it in enumerate(items):
                if it['w'] <= W and it['d'] == best_single:
                    used[i] = 1
                    td = best_single
                    break
        print_solution(used, td)
        return

    # reactive GRASP+ILS parameters
    ALPHAS    = [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]
    PERTS     = [0.05, 0.1, 0.15, 0.2]
    alpha_scores = {a:1.0 for a in ALPHAS}
    pert_scores  = {p:1.0 for p in PERTS}

    ILS_RESTARTS   = 20
    MAX_NO_IMPROVE = min(2000, max(500, n//2))
    M_FOCUS        = 300
    TIME_LIMIT     = 59.0
    start_time     = time.time()

    best_d = best_single

    # If best_single is better than 0, initialize best_used appropriately
    if best_single > 0:
        best_used = [0]*n
        for i, it in enumerate(items):
            if it['w'] <= W and it['d'] == best_single:
                best_used[i] = 1
                break

    # main loop
    while (time.time() - start_time) < TIME_LIMIT:
        alpha     = sample_adaptive(alpha_scores)
        drop_rate = sample_adaptive(pert_scores)

        # GRASP construction
        used, tw, td = grasp_construct(n, W, items, idx, alpha)

        # Local search
        used, tw, td = local_search(used, items, W, idx,
                                    start_time, TIME_LIMIT,
                                    MAX_NO_IMPROVE, M_FOCUS)

        # ILS restarts
        for _ in range(ILS_RESTARTS):
            used = perturb(used, items, W, idx, drop_rate)
            used, tw, td = local_search(used, items, W, idx,
                                        start_time, TIME_LIMIT,
                                        MAX_NO_IMPROVE, M_FOCUS)

        # record and adapt
        if td > best_d:
            best_d = td
            best_used = used.copy()
            alpha_scores[alpha] += 1
            pert_scores[drop_rate] += 1

    # Print final solution
    print_solution(best_used if best_used is not None else [0]*n, best_d)

if __name__ == "__main__":
    main()