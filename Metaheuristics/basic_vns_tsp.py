# -*- coding: utf-8 -*-
"""Basic_VNS_TSP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZMAmpMQEqgUuDaIe5zvFWh6XipzsAEJ8
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

# --------------------- utilities ---------------------
def total_distance(tour, dist):
    """Closed‑tour length."""
    return sum(dist[tour[i], tour[(i + 1) % len(tour)]] for i in range(len(tour)))


# ---------- Algorithm 5 : Best‑Improvement 2‑opt ----------
def best_improvement(tour, dist_matrix):
    """
    Steepest‑descent 2‑opt:
      – scan ALL (i,j) pairs, pick the one that yields the largest drop in length,
        apply it, repeat until no 2‑opt move improves the tour.
    """
    n = len(tour)
    improved = True
    while improved:
        improved = False
        best_delta = 0.0
        best_pair = None

        # evaluate every 2‑opt edge swap
        for i in range(n - 1):
            for j in range(i + 2, n if i else n - 1):  # avoid adjacent edges & duplicate tour end
                a, b = tour[i], tour[(i + 1) % n]
                c, d = tour[j], tour[(j + 1) % n]
                delta = (dist_matrix[a, c] + dist_matrix[b, d]) - (
                    dist_matrix[a, b] + dist_matrix[c, d]
                )
                if delta < best_delta:
                    best_delta = delta
                    best_pair = (i + 1, j)

        # apply the steepest move
        if best_pair:
            i, j = best_pair
            tour[i : j + 1] = reversed(tour[i : j + 1])
            improved = True

    return tour, total_distance(tour, dist_matrix)

# ------------- Algorithm 6 (first‑impr.) -------------
def first_improvement_2opt(tour, dist):
    """
    2‑opt descent: apply the first improving edge exchange you find;
    keep looping until no improvement exists (first‑improvement ≈ linear‑time on
    average, but converges to the same 2‑opt optimum as best‑improvement).
    """
    n = len(tour)
    improved = True
    while improved:
        improved = False
        for i in range(n - 1):
            for j in range(i + 2, n if i else n - 1):
                a, b = tour[i], tour[(i + 1) % n]
                c, d = tour[j], tour[(j + 1) % n]
                delta = (dist[a, c] + dist[b, d]) - (dist[a, b] + dist[c, d])
                if delta < -1e-12:                       # strictly better
                    tour[i + 1 : j + 1] = reversed(tour[i + 1 : j + 1])
                    improved = True
                    break
            if improved:
                break
    return tour, total_distance(tour, dist)



# ----------------- Algorithm 4 : Shake ----------------
def shake(tour, k):
    """k=1 ‑ swap ; k=2 ‑ single 2‑opt reversal."""
    new = tour.copy()
    n = len(tour)
    if k == 1:
        i, j = np.random.choice(n, 2, replace=False)
        new[i], new[j] = new[j], new[i]
    else:  # k == 2
        i, j = sorted(np.random.choice(n, 2, replace=False))
        new[i : j + 1] = reversed(new[i : j + 1])
    return new


# -------- Algorithm 1 : NeighborhoodChange ----------
def neighbourhood_change(x, xp, k, k_max, dist):
    if total_distance(xp, dist) < total_distance(x, dist):
        return xp, 1            # improvement → restart from N1
    k += 1                      # else → next neighbourhood
    return x, k


# --------- Algorithm 7 : Basic VNS (iteration‑based) ---------
def basic_vns(dist, k_max=2, max_outer=250, *, improv='best'):
    """
    improv : {'best', 'first'}
        'best'  – run the steepest‑descent 2‑opt (best_improvement)
        'first' – run the first‑improvement 2‑opt (first_improvement_2opt)
    """
    n = dist.shape[0]
    x = list(np.random.permutation(n))
    outer = 0

    # choose the local‑search routine just once outside the loop
    if improv == 'best':
        local_search = best_improvement
    elif improv == 'first':
        local_search = first_improvement_2opt
    else:
        raise ValueError("improv must be 'best' or 'first'")

    while outer < max_outer:
        k = 1
        while k <= k_max:
            xp = shake(x, k)                  # Algorithm 4: Shaking
            xp, _ = local_search(xp, dist)    # Alg. 5 or 6: Local search
            x, k = neighbourhood_change(x, xp, k, k_max, dist)  # Alg. 1
        outer += 1
    return x, total_distance(x, dist)

# --------------------------- demo ---------------------------
def main(dist=None, show_plots=False):
    """
    Run the VNS demo.

    Parameters
    ----------
    dist : np.ndarray | None
        Square, symmetric distance matrix.  If None, one is generated
        from random coordinates.
    show_plots : bool
        Draw the complete graph and the best tour.
    """
    # ------------------------------------------------------------------
    # 1. Either accept the user's matrix or create one from random coords
    # ------------------------------------------------------------------
    if dist is None:
        n = 5                       # or any value you like
        coords = np.random.rand(n, 2) * 100           # ~0-140 distances
        dist   = np.linalg.norm(coords[:, None] - coords[None, :], axis=2)
        dist   = np.rint(dist).astype(int)
    else:
        # Sanity checks
        dist = np.asarray(dist, dtype=int)
        assert dist.ndim == 2 and dist.shape[0] == dist.shape[1], \
            "dist must be a square matrix"
        n = dist.shape[0]
        # Optional: fabricate coordinates for plotting (MDS, spring, …)
        coords = nx.spring_layout(nx.complete_graph(n), seed=0)

    print("\nDistance matrix :\n", dist)

    best_tour, best_len = basic_vns(dist, k_max=2, max_outer=200)
    print("\nBest tour:", np.array(best_tour))
    print(f"Tour length: {best_len:.3f}")

    if show_plots:
        G = nx.complete_graph(n)
        if isinstance(coords, dict):          # spring_layout case
            pos = coords
        else:                                 # random-coord case
            pos = {i: coords[i] for i in range(n)}

        for i, j in G.edges():
            G[i][j]["weight"] = dist[i, j]

        plt.figure()
        nx.draw(G, pos, with_labels=True)
        nx.draw_networkx_edge_labels(
            G, pos,
            edge_labels={(i, j): f"{dist[i, j]}" for i, j in G.edges()},
            font_size=8,
        )
        plt.title("Complete graph"); plt.axis("off")

        plt.figure()
        nx.draw(G, pos, with_labels=True)
        tour_edges = [(best_tour[i], best_tour[(i + 1) % n]) for i in range(n)]
        nx.draw_networkx_edges(G, pos, edgelist=tour_edges, width=2)
        plt.title(f"Best tour (len={best_len})"); plt.axis("off")
        plt.show()


if __name__ == "__main__":
    #np.random.seed(42)
    fixed_dist = np.array([
        [0, 50, 82, 33, 33],
        [50, 0, 73, 73, 17],
        [82, 73, 0, 72, 71],
        [33, 73, 72, 0, 57],
        [33, 17, 71, 57, 0],
    ])
    main(dist=fixed_dist, show_plots=True)
    #main(show_plots=True, n = 5)   # 5 Cities

