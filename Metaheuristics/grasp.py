# -*- coding: utf-8 -*-
"""GRASP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qpUJI7Rn4dFOkR6nDIftwcdIojxzf8kQ
"""

#!/usr/bin/env python3
"""
GRASP for the Uncapacitated Facility Location Problem with a cardinality constraint (max k facilities).
Example data from the slides:
  - 5 facilities, opening costs = [100, 90, 80, 110, 120]
  - 8 customers, demands = [1,1,...,1]
  - Service cost matrix (5 x 8)
  - k = 2
"""

import random
import copy

# --------------------------------------------
# Example data  (excercise)
# --------------------------------------------

# Number of facilities (n) and customers (m)
n = 5
m = 8

# Opening costs for each facility (0-indexed)
#   f_i = cost to open facility i
opening_costs = [100, 90, 80, 110, 120]

# (Optional) Demands for each customer. In an uncapacitated problem,
# demands only matter if you want to weight service costs.
# In this example, all demands = 1 → we ignore them in the service‐cost sum.
demands = [1 for _ in range(m)]

# Service cost matrix: cost_matrix[i][j] = cost to serve customer j from facility i
#           C1   C2   C3   C4   C5   C6   C7   C8
cost_matrix = [
    [ 20,  24,  18,  25,  30,  35,  28,  22],  # Facility 0 (F1)
    [ 18,  20,  22,  23,  27,  33,  31,  19],  # Facility 1 (F2)
    [ 25,  21,  20,  18,  22,  26,  30,  24],  # Facility 2 (F3)
    [ 30,  28,  25,  20,  18,  21,  23,  26],  # Facility 3 (F4)
    [ 35,  32,  30,  27,  25,  24,  26,  29],  # Facility 4 (F5)
]

# Maximum number of facilities to open
k = 2

# --------------------------------------------
# GRASP parameters
# --------------------------------------------
alpha = 0.3       # RCL threshold as a fraction (0 < alpha <= 1). Smaller → greedier
max_iter = 100    # Number of GRASP iterations

# --------------------------------------------
# Helper functions
# --------------------------------------------

def compute_total_cost(open_set, assign):
    """
    Compute total cost = sum of opening costs for open_set + sum of service costs:
      open_set: set of facility indices that are open (e.g. {0, 2})
      assign:  list of length m, assign[j] = facility index serving customer j
    """
    # Opening cost
    cost_open = sum(opening_costs[i] for i in open_set)
    # Service cost
    cost_service = 0
    for j in range(m):
        i = assign[j]
        cost_service += cost_matrix[i][j] * demands[j]
    return cost_open + cost_service

def assign_customers_to_nearest(open_set):
    """
    Given a set of open facilities, assign each customer j to the open facility i with minimal cost_matrix[i][j].
    Returns a list `assign` of length m, where assign[j] is the chosen facility index for customer j.
    """
    assign = [-1] * m
    for j in range(m):
        best_fac = None
        best_cost = float('inf')
        for i in open_set:
            c = cost_matrix[i][j] * demands[j]
            if c < best_cost:
                best_cost = c
                best_fac = i
        assign[j] = best_fac
    return assign

def greedy_randomized_construction(alpha, k):
    """
    Construct a feasible solution with exactly k facilities open:
     1) Compute for each facility i a "score" = opening_costs[i] + sum_j cost_matrix[i][j].
     2) Sort facilities by that score ascending.
     3) Build an RCL consisting of the top r facilities, where r = max(1, floor(alpha * n)).
     4) Randomly pick one from RCL, add to open_set, remove it from candidate list.
     5) Repeat steps 1–4 until |open_set| == k.
     6) Assign customers to their nearest open facility.
    Returns: (open_set, assign_list)
    """
    # Start with no open facilities
    open_set = set()
    candidates = set(range(n))
    # Precompute the sum_j cost_matrix[i][j] for each i
    sum_service_cost = [sum(cost_matrix[i][j] * demands[j] for j in range(m)) for i in range(n)]

    while len(open_set) < k:
        # Build a list of (facility, score) for all candidates not yet open
        score_list = []
        for i in candidates:
            score_i = opening_costs[i] + sum_service_cost[i]
            score_list.append((i, score_i))
        # Sort by score ascending
        score_list.sort(key=lambda x: x[1])

        # Determine RCL size: r = max(1, floor(alpha * |candidates|))
        r = max(1, int(alpha * len(score_list)))

        # Restricted Candidate List = first r elements of score_list
        RCL = [facility for facility, _ in score_list[:r]]

        # Randomly choose one facility from RCL
        chosen = random.choice(RCL)
        open_set.add(chosen)
        candidates.remove(chosen)

    # Now assign customers to nearest open facility
    assign = assign_customers_to_nearest(open_set)
    return open_set, assign

def local_search(open_set, assign):
    """
    Given an initial (open_set, assign), attempt to improve by single‐swap:
      - Try swapping one open facility i_open with one closed facility i_closed.
      - If the swap lowers total cost, accept it and restart local search.
    Returns an improved (open_set, assign) or the same if no improving swap exists.
    """
    current_open = set(open_set)
    current_assign = list(assign)
    current_cost = compute_total_cost(current_open, current_assign)

    improved = True
    while improved:
        improved = False
        best_swap = None
        best_new_cost = current_cost

        closed_set = set(range(n)) - current_open

        # Try all single‐swap pairs: (i_open, i_closed)
        for i_open in current_open:
            for i_closed in closed_set:
                # Perform the swap
                new_open = set(current_open)
                new_open.remove(i_open)
                new_open.add(i_closed)

                # Reassign customers
                new_assign = assign_customers_to_nearest(new_open)
                new_cost = compute_total_cost(new_open, new_assign)

                # If strictly better, store this swap
                if new_cost < best_new_cost:
                    best_new_cost = new_cost
                    best_swap = (i_open, i_closed, new_open, new_assign)

        # If we found an improving swap, accept it and loop again
        if best_swap is not None:
            _, _, swapped_open, swapped_assign = best_swap
            current_open = swapped_open
            current_assign = swapped_assign
            current_cost = best_new_cost
            improved = True

    return current_open, current_assign

# --------------------------------------------
# Main GRASP loop
# --------------------------------------------
if __name__ == "__main__":
    random.seed(42)  # for reproducibility, you can remove or change the seed

    best_overall_cost = float('inf')
    best_overall_open = None
    best_overall_assign = None

    for iteration in range(max_iter):
        # 1) Construction
        open_set, assign_list = greedy_randomized_construction(alpha, k)

        # 2) Local search
        open_set_ls, assign_ls = local_search(open_set, assign_list)

        # 3) Evaluate
        cost_ls = compute_total_cost(open_set_ls, assign_ls)
        if cost_ls < best_overall_cost:
            best_overall_cost = cost_ls
            best_overall_open = set(open_set_ls)
            best_overall_assign = list(assign_ls)

    # --------------------------------------------
    # Print the best solution found
    # --------------------------------------------
    print("========== Best GRASP Solution Found ==========")
    print(f"Facilities opened (0‐indexed): {sorted(best_overall_open)}")
    print(f"Opening costs sum: {sum(opening_costs[i] for i in best_overall_open)}")
    print("Customer assignments (customer j → facility i):")
    for j in range(m):
        print(f"  Customer {j} → Facility {best_overall_assign[j]} (service cost = "
              f"{cost_matrix[best_overall_assign[j]][j]})")
    print(f"Total cost (open + service): {best_overall_cost}")

